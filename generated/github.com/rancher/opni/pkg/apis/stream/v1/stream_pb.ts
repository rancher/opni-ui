// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/rancher/opni/pkg/apis/stream/v1/stream.proto (package stream, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { RPC } from "../../../../../../kralicky/totem/totem_pb";
import { ClusterSelector, Reference } from "../../core/v1/core_pb";
import { Status } from "../../../../../../../google/rpc/status_pb";

/**
 * @generated from enum stream.EventType
 */
export enum EventType {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: DiscoveryComplete = 1;
   */
  DiscoveryComplete = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(EventType)
proto3.util.setEnumType(EventType, "stream.EventType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "DiscoveryComplete" },
]);

/**
 * @generated from message stream.StreamEvent
 */
export class StreamEvent extends Message<StreamEvent> {
  /**
   * @generated from field: stream.EventType type = 1;
   */
  type = EventType.Unknown;

  constructor(data?: PartialMessage<StreamEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.StreamEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(EventType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEvent {
    return new StreamEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEvent {
    return new StreamEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEvent {
    return new StreamEvent().fromJsonString(jsonString, options);
  }

  static equals(a: StreamEvent | PlainMessage<StreamEvent> | undefined, b: StreamEvent | PlainMessage<StreamEvent> | undefined): boolean {
    return proto3.util.equals(StreamEvent, a, b);
  }
}

/**
 * @generated from message stream.DelegatedMessage
 */
export class DelegatedMessage extends Message<DelegatedMessage> {
  /**
   * @generated from field: totem.RPC request = 1;
   */
  request?: RPC;

  /**
   * @generated from field: core.Reference target = 2;
   */
  target?: Reference;

  constructor(data?: PartialMessage<DelegatedMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.DelegatedMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: RPC },
    { no: 2, name: "target", kind: "message", T: Reference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegatedMessage {
    return new DelegatedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegatedMessage {
    return new DelegatedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegatedMessage {
    return new DelegatedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: DelegatedMessage | PlainMessage<DelegatedMessage> | undefined, b: DelegatedMessage | PlainMessage<DelegatedMessage> | undefined): boolean {
    return proto3.util.equals(DelegatedMessage, a, b);
  }
}

/**
 * @generated from message stream.DelegatedMessageReply
 */
export class DelegatedMessageReply extends Message<DelegatedMessageReply> {
  /**
   * @generated from field: totem.RPC reply = 1;
   */
  reply?: RPC;

  /**
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;

  constructor(data?: PartialMessage<DelegatedMessageReply>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.DelegatedMessageReply";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reply", kind: "message", T: RPC },
    { no: 2, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DelegatedMessageReply {
    return new DelegatedMessageReply().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DelegatedMessageReply {
    return new DelegatedMessageReply().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DelegatedMessageReply {
    return new DelegatedMessageReply().fromJsonString(jsonString, options);
  }

  static equals(a: DelegatedMessageReply | PlainMessage<DelegatedMessageReply> | undefined, b: DelegatedMessageReply | PlainMessage<DelegatedMessageReply> | undefined): boolean {
    return proto3.util.equals(DelegatedMessageReply, a, b);
  }
}

/**
 * @generated from message stream.BroadcastMessage
 */
export class BroadcastMessage extends Message<BroadcastMessage> {
  /**
   * @generated from field: totem.RPC request = 1;
   */
  request?: RPC;

  /**
   * @generated from field: core.ClusterSelector targetSelector = 2;
   */
  targetSelector?: ClusterSelector;

  constructor(data?: PartialMessage<BroadcastMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.BroadcastMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: RPC },
    { no: 2, name: "targetSelector", kind: "message", T: ClusterSelector },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastMessage {
    return new BroadcastMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastMessage {
    return new BroadcastMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastMessage {
    return new BroadcastMessage().fromJsonString(jsonString, options);
  }

  static equals(a: BroadcastMessage | PlainMessage<BroadcastMessage> | undefined, b: BroadcastMessage | PlainMessage<BroadcastMessage> | undefined): boolean {
    return proto3.util.equals(BroadcastMessage, a, b);
  }
}

/**
 * @generated from message stream.BroadcastReplyList
 */
export class BroadcastReplyList extends Message<BroadcastReplyList> {
  /**
   * @generated from field: repeated stream.BroadcastReply responses = 1;
   */
  responses: BroadcastReply[] = [];

  constructor(data?: PartialMessage<BroadcastReplyList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.BroadcastReplyList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: BroadcastReply, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastReplyList {
    return new BroadcastReplyList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastReplyList {
    return new BroadcastReplyList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastReplyList {
    return new BroadcastReplyList().fromJsonString(jsonString, options);
  }

  static equals(a: BroadcastReplyList | PlainMessage<BroadcastReplyList> | undefined, b: BroadcastReplyList | PlainMessage<BroadcastReplyList> | undefined): boolean {
    return proto3.util.equals(BroadcastReplyList, a, b);
  }
}

/**
 * @generated from message stream.BroadcastReply
 */
export class BroadcastReply extends Message<BroadcastReply> {
  /**
   * @generated from field: core.Reference ref = 1;
   */
  ref?: Reference;

  /**
   * @generated from field: totem.RPC reply = 2;
   */
  reply?: RPC;

  constructor(data?: PartialMessage<BroadcastReply>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "stream.BroadcastReply";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ref", kind: "message", T: Reference },
    { no: 2, name: "reply", kind: "message", T: RPC },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BroadcastReply {
    return new BroadcastReply().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BroadcastReply {
    return new BroadcastReply().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BroadcastReply {
    return new BroadcastReply().fromJsonString(jsonString, options);
  }

  static equals(a: BroadcastReply | PlainMessage<BroadcastReply> | undefined, b: BroadcastReply | PlainMessage<BroadcastReply> | undefined): boolean {
    return proto3.util.equals(BroadcastReply, a, b);
  }
}

