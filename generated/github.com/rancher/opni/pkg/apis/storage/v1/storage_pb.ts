// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/rancher/opni/pkg/apis/storage/v1/storage.proto (package storage, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Duration } from "../../../../../../../google/protobuf/duration_pb";

/**
 * @generated from enum storage.Backend
 */
export enum Backend {
  /**
   * @generated from enum value: filesystem = 0;
   */
  filesystem = 0,

  /**
   * @generated from enum value: s3 = 1;
   */
  s3 = 1,

  /**
   * @generated from enum value: gcs = 2;
   */
  gcs = 2,

  /**
   * @generated from enum value: azure = 3;
   */
  azure = 3,

  /**
   * @generated from enum value: swift = 4;
   */
  swift = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Backend)
proto3.util.setEnumType(Backend, "storage.Backend", [
  { no: 0, name: "filesystem" },
  { no: 1, name: "s3" },
  { no: 2, name: "gcs" },
  { no: 3, name: "azure" },
  { no: 4, name: "swift" },
]);

/**
 * @generated from message storage.StorageSpec
 */
export class StorageSpec extends Message<StorageSpec> {
  /**
   * Name of the storage backend to use.
   * +kubebuilder:validation:Schemaless
   * +kubebuilder:validation:Type:=string
   *
   * @generated from field: storage.Backend backend = 1;
   */
  backend = Backend.filesystem;

  /**
   * @generated from field: storage.S3StorageSpec s3 = 2;
   */
  s3?: S3StorageSpec;

  /**
   * @generated from field: storage.GCSStorageSpec gcs = 3;
   */
  gcs?: GCSStorageSpec;

  /**
   * @generated from field: storage.AzureStorageSpec azure = 4;
   */
  azure?: AzureStorageSpec;

  /**
   * @generated from field: storage.SwiftStorageSpec swift = 5;
   */
  swift?: SwiftStorageSpec;

  /**
   * @generated from field: storage.FilesystemStorageSpec filesystem = 6;
   */
  filesystem?: FilesystemStorageSpec;

  constructor(data?: PartialMessage<StorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.StorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "backend", kind: "enum", T: proto3.getEnumType(Backend) },
    { no: 2, name: "s3", kind: "message", T: S3StorageSpec },
    { no: 3, name: "gcs", kind: "message", T: GCSStorageSpec },
    { no: 4, name: "azure", kind: "message", T: AzureStorageSpec },
    { no: 5, name: "swift", kind: "message", T: SwiftStorageSpec },
    { no: 6, name: "filesystem", kind: "message", T: FilesystemStorageSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageSpec {
    return new StorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageSpec {
    return new StorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageSpec {
    return new StorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: StorageSpec | PlainMessage<StorageSpec> | undefined, b: StorageSpec | PlainMessage<StorageSpec> | undefined): boolean {
    return proto3.util.equals(StorageSpec, a, b);
  }
}

/**
 * @generated from message storage.S3StorageSpec
 */
export class S3StorageSpec extends Message<S3StorageSpec> {
  /**
   * The S3 bucket endpoint. It could be an AWS S3 endpoint listed at
   * https://docs.aws.amazon.com/general/latest/gr/s3.html or the address of an
   * S3-compatible service in hostname:port format.
   *
   * @generated from field: string endpoint = 1;
   */
  endpoint = "";

  /**
   * S3 region. If unset, the client will issue a S3 GetBucketLocation API call
   * to autodetect it.
   *
   * @generated from field: string region = 2;
   */
  region = "";

  /**
   * S3 bucket name
   *
   * @generated from field: string bucketName = 3;
   */
  bucketName = "";

  /**
   * S3 secret access key
   *
   * @generated from field: string secretAccessKey = 4;
   */
  secretAccessKey = "";

  /**
   * S3 access key ID
   *
   * @generated from field: string accessKeyID = 5;
   */
  accessKeyID = "";

  /**
   * If enabled, use http:// for the S3 endpoint instead of https://. This could
   * be useful in local dev/test environments while using an S3-compatible
   * backend storage, like Minio.
   *
   * @generated from field: bool insecure = 6;
   */
  insecure = false;

  /**
   * The signature version to use for authenticating against S3.
   * Supported values are: v4, v2
   *
   * @generated from field: string signatureVersion = 7;
   */
  signatureVersion = "";

  /**
   * @generated from field: storage.SSEConfig sse = 8;
   */
  sse?: SSEConfig;

  /**
   * @generated from field: storage.HTTPConfig http = 9;
   */
  http?: HTTPConfig;

  constructor(data?: PartialMessage<S3StorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.S3StorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "bucketName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "secretAccessKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "accessKeyID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "insecure", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "signatureVersion", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "sse", kind: "message", T: SSEConfig },
    { no: 9, name: "http", kind: "message", T: HTTPConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): S3StorageSpec {
    return new S3StorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): S3StorageSpec {
    return new S3StorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): S3StorageSpec {
    return new S3StorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: S3StorageSpec | PlainMessage<S3StorageSpec> | undefined, b: S3StorageSpec | PlainMessage<S3StorageSpec> | undefined): boolean {
    return proto3.util.equals(S3StorageSpec, a, b);
  }
}

/**
 * @generated from message storage.SSEConfig
 */
export class SSEConfig extends Message<SSEConfig> {
  /**
   * Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * KMS Key ID used to encrypt objects in S3
   *
   * @generated from field: string kmsKeyID = 2;
   */
  kmsKeyID = "";

  /**
   * KMS Encryption Context used for object encryption. It expects a JSON formatted string.
   *
   * @generated from field: string kmsEncryptionContext = 3;
   */
  kmsEncryptionContext = "";

  constructor(data?: PartialMessage<SSEConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.SSEConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "kmsKeyID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "kmsEncryptionContext", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSEConfig {
    return new SSEConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSEConfig {
    return new SSEConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSEConfig {
    return new SSEConfig().fromJsonString(jsonString, options);
  }

  static equals(a: SSEConfig | PlainMessage<SSEConfig> | undefined, b: SSEConfig | PlainMessage<SSEConfig> | undefined): boolean {
    return proto3.util.equals(SSEConfig, a, b);
  }
}

/**
 * @generated from message storage.HTTPConfig
 */
export class HTTPConfig extends Message<HTTPConfig> {
  /**
   * The time an idle connection will remain idle before closing.
   *
   * @generated from field: google.protobuf.Duration idleConnTimeout = 1;
   */
  idleConnTimeout?: Duration;

  /**
   * The amount of time the client will wait for a servers response headers.
   *
   * @generated from field: google.protobuf.Duration responseHeaderTimeout = 2;
   */
  responseHeaderTimeout?: Duration;

  /**
   * If the client connects via HTTPS and this option is enabled, the client will accept any certificate and hostname.
   *
   * @generated from field: bool insecureSkipVerify = 3;
   */
  insecureSkipVerify = false;

  /**
   * Maximum time to wait for a TLS handshake. 0 means no limit.
   *
   * @generated from field: google.protobuf.Duration tlsHandshakeTimeout = 4;
   */
  tlsHandshakeTimeout?: Duration;

  /**
   * The time to wait for a server's first response headers after fully writing the request headers if the request has an Expect header. 0 to send the request body immediately.
   *
   * @generated from field: google.protobuf.Duration expectContinueTimeout = 5;
   */
  expectContinueTimeout?: Duration;

  /**
   * Maximum number of idle (keep-alive) connections across all hosts. 0 means no limit.
   *
   * @generated from field: int32 maxIdleConns = 6;
   */
  maxIdleConns = 0;

  /**
   * Maximum number of idle (keep-alive) connections to keep per-host. If 0, a built-in default value is used.
   *
   * @generated from field: int32 maxIdleConnsPerHost = 7;
   */
  maxIdleConnsPerHost = 0;

  /**
   * Maximum number of connections per host. 0 means no limit.
   *
   * @generated from field: int32 maxConnsPerHost = 8;
   */
  maxConnsPerHost = 0;

  constructor(data?: PartialMessage<HTTPConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.HTTPConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "idleConnTimeout", kind: "message", T: Duration },
    { no: 2, name: "responseHeaderTimeout", kind: "message", T: Duration },
    { no: 3, name: "insecureSkipVerify", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "tlsHandshakeTimeout", kind: "message", T: Duration },
    { no: 5, name: "expectContinueTimeout", kind: "message", T: Duration },
    { no: 6, name: "maxIdleConns", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "maxIdleConnsPerHost", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "maxConnsPerHost", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HTTPConfig {
    return new HTTPConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HTTPConfig {
    return new HTTPConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HTTPConfig {
    return new HTTPConfig().fromJsonString(jsonString, options);
  }

  static equals(a: HTTPConfig | PlainMessage<HTTPConfig> | undefined, b: HTTPConfig | PlainMessage<HTTPConfig> | undefined): boolean {
    return proto3.util.equals(HTTPConfig, a, b);
  }
}

/**
 * @generated from message storage.GCSStorageSpec
 */
export class GCSStorageSpec extends Message<GCSStorageSpec> {
  /**
   * GCS bucket name
   *
   * @generated from field: string bucketName = 1;
   */
  bucketName = "";

  /**
   * JSON representing either a Google Developers Console client_credentials.json file
   * or a Google Developers service account key file. If empty, fallback to Google default logic.
   *
   * @generated from field: string serviceAccount = 2;
   */
  serviceAccount = "";

  constructor(data?: PartialMessage<GCSStorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.GCSStorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucketName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "serviceAccount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GCSStorageSpec {
    return new GCSStorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GCSStorageSpec {
    return new GCSStorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GCSStorageSpec {
    return new GCSStorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: GCSStorageSpec | PlainMessage<GCSStorageSpec> | undefined, b: GCSStorageSpec | PlainMessage<GCSStorageSpec> | undefined): boolean {
    return proto3.util.equals(GCSStorageSpec, a, b);
  }
}

/**
 * @generated from message storage.AzureStorageSpec
 */
export class AzureStorageSpec extends Message<AzureStorageSpec> {
  /**
   * Azure storage account name
   *
   * @generated from field: string storageAccountName = 1;
   */
  storageAccountName = "";

  /**
   * Azure storage account key
   *
   * @generated from field: string storageAccountKey = 2;
   */
  storageAccountKey = "";

  /**
   * Azure storage container name
   *
   * @generated from field: string containerName = 3;
   */
  containerName = "";

  /**
   * Azure storage endpoint suffix without schema. The account name will be
   * prefixed to this value to create the FQDN
   *
   * @generated from field: string endpoint = 4;
   */
  endpoint = "";

  /**
   * Number of retries for recoverable errors
   *
   * @generated from field: int32 maxRetries = 5;
   */
  maxRetries = 0;

  /**
   * Azure storage MSI resource. Either this or account key must be set.
   *
   * @generated from field: string msiResource = 6;
   */
  msiResource = "";

  /**
   * Azure storage MSI resource managed identity client Id. If not supplied system assigned identity is used
   *
   * @generated from field: string userAssignedID = 7;
   */
  userAssignedID = "";

  /**
   * @generated from field: storage.HTTPConfig http = 8;
   */
  http?: HTTPConfig;

  constructor(data?: PartialMessage<AzureStorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.AzureStorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storageAccountName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storageAccountKey", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "containerName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "maxRetries", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "msiResource", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "userAssignedID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "http", kind: "message", T: HTTPConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AzureStorageSpec {
    return new AzureStorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AzureStorageSpec {
    return new AzureStorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AzureStorageSpec {
    return new AzureStorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: AzureStorageSpec | PlainMessage<AzureStorageSpec> | undefined, b: AzureStorageSpec | PlainMessage<AzureStorageSpec> | undefined): boolean {
    return proto3.util.equals(AzureStorageSpec, a, b);
  }
}

/**
 * @generated from message storage.SwiftStorageSpec
 */
export class SwiftStorageSpec extends Message<SwiftStorageSpec> {
  /**
   * OpenStack Swift authentication API version. 0 to autodetect.
   *
   * @generated from field: int32 authVersion = 1;
   */
  authVersion = 0;

  /**
   * OpenStack Swift authentication URL.
   *
   * @generated from field: string authURL = 2;
   */
  authURL = "";

  /**
   * OpenStack Swift username.
   *
   * @generated from field: string username = 3;
   */
  username = "";

  /**
   * OpenStack Swift user's domain name.
   *
   * @generated from field: string userDomainName = 4;
   */
  userDomainName = "";

  /**
   * OpenStack Swift user's domain ID.
   *
   * @generated from field: string userDomainID = 5;
   */
  userDomainID = "";

  /**
   * OpenStack Swift user ID.
   *
   * @generated from field: string userID = 6;
   */
  userID = "";

  /**
   * OpenStack Swift API key.
   *
   * @generated from field: string password = 7;
   */
  password = "";

  /**
   * OpenStack Swift user's domain ID.
   *
   * @generated from field: string domainID = 8;
   */
  domainID = "";

  /**
   * OpenStack Swift user's domain name.
   *
   * @generated from field: string domainName = 9;
   */
  domainName = "";

  /**
   * OpenStack Swift project ID (v2,v3 auth only).
   *
   * @generated from field: string projectID = 10;
   */
  projectID = "";

  /**
   * OpenStack Swift project name (v2,v3 auth only).
   *
   * @generated from field: string projectName = 11;
   */
  projectName = "";

  /**
   * ID of the OpenStack Swift project's domain (v3 auth only), only needed
   * if it differs the from user domain.
   *
   * @generated from field: string projectDomainID = 12;
   */
  projectDomainID = "";

  /**
   * Name of the OpenStack Swift project's domain (v3 auth only), only needed
   * if it differs from the user domain.
   *
   * @generated from field: string projectDomainName = 13;
   */
  projectDomainName = "";

  /**
   * OpenStack Swift Region to use (v2,v3 auth only).
   *
   * @generated from field: string regionName = 14;
   */
  regionName = "";

  /**
   * Name of the OpenStack Swift container to use. The container must already
   * exist.
   *
   * @generated from field: string containerName = 15;
   */
  containerName = "";

  /**
   * Max number of times to retry failed requests.
   *
   * @generated from field: int32 maxRetries = 16;
   */
  maxRetries = 0;

  /**
   * Time after which a connection attempt is aborted.
   *
   * @generated from field: google.protobuf.Duration connectTimeout = 17;
   */
  connectTimeout?: Duration;

  /**
   * Time after which an idle request is aborted. The timeout watchdog is reset
   * each time some data is received, so the timeout triggers after X time no
   * data is received on a request.
   *
   * @generated from field: google.protobuf.Duration requestTimeout = 18;
   */
  requestTimeout?: Duration;

  constructor(data?: PartialMessage<SwiftStorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.SwiftStorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authVersion", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "authURL", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "userDomainName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "userDomainID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "userID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "domainID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "domainName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "projectID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "projectName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "projectDomainID", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "projectDomainName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "regionName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "containerName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "maxRetries", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 17, name: "connectTimeout", kind: "message", T: Duration },
    { no: 18, name: "requestTimeout", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SwiftStorageSpec {
    return new SwiftStorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SwiftStorageSpec {
    return new SwiftStorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SwiftStorageSpec {
    return new SwiftStorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: SwiftStorageSpec | PlainMessage<SwiftStorageSpec> | undefined, b: SwiftStorageSpec | PlainMessage<SwiftStorageSpec> | undefined): boolean {
    return proto3.util.equals(SwiftStorageSpec, a, b);
  }
}

/**
 * @generated from message storage.FilesystemStorageSpec
 */
export class FilesystemStorageSpec extends Message<FilesystemStorageSpec> {
  /**
   * Local filesystem storage directory.
   *
   * @generated from field: string directory = 1;
   */
  directory = "";

  constructor(data?: PartialMessage<FilesystemStorageSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "storage.FilesystemStorageSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directory", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilesystemStorageSpec {
    return new FilesystemStorageSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilesystemStorageSpec {
    return new FilesystemStorageSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilesystemStorageSpec {
    return new FilesystemStorageSpec().fromJsonString(jsonString, options);
  }

  static equals(a: FilesystemStorageSpec | PlainMessage<FilesystemStorageSpec> | undefined, b: FilesystemStorageSpec | PlainMessage<FilesystemStorageSpec> | undefined): boolean {
    return proto3.util.equals(FilesystemStorageSpec, a, b);
  }
}

