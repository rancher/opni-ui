// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/rancher/opni/plugins/metrics/pkg/apis/node/node.proto (package node.metrics, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Reference } from "../../../../../pkg/apis/core/v1/core_pb";
import { RulesSpec } from "../../../../../pkg/config/v1beta1/agent_config_pb";
import { Duration } from "../../../../../../../../google/protobuf/duration_pb";

/**
 * @generated from enum node.metrics.ConfigStatus
 */
export enum ConfigStatus {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: UpToDate = 1;
   */
  UpToDate = 1,

  /**
   * @generated from enum value: NeedsUpdate = 2;
   */
  NeedsUpdate = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConfigStatus)
proto3.util.setEnumType(ConfigStatus, "node.metrics.ConfigStatus", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "UpToDate" },
  { no: 2, name: "NeedsUpdate" },
]);

/**
 * @generated from message node.metrics.NodeConfigRequest
 */
export class NodeConfigRequest extends Message<NodeConfigRequest> {
  /**
   * @generated from field: core.Reference node = 1;
   */
  node?: Reference;

  /**
   * Can be set to nil to use the default configuration for this node.
   *
   * @generated from field: node.metrics.MetricsCapabilitySpec spec = 2;
   */
  spec?: MetricsCapabilitySpec;

  constructor(data?: PartialMessage<NodeConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.NodeConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node", kind: "message", T: Reference },
    { no: 2, name: "spec", kind: "message", T: MetricsCapabilitySpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeConfigRequest {
    return new NodeConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeConfigRequest {
    return new NodeConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeConfigRequest {
    return new NodeConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: NodeConfigRequest | PlainMessage<NodeConfigRequest> | undefined, b: NodeConfigRequest | PlainMessage<NodeConfigRequest> | undefined): boolean {
    return proto3.util.equals(NodeConfigRequest, a, b);
  }
}

/**
 * @generated from message node.metrics.MetricsCapabilityConfig
 */
export class MetricsCapabilityConfig extends Message<MetricsCapabilityConfig> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * If enabled is false, conditions may contain a list of relevant status
   * messages describing why the capability is disabled.
   *
   * @generated from field: repeated string conditions = 2;
   */
  conditions: string[] = [];

  /**
   * @generated from field: node.metrics.MetricsCapabilitySpec spec = 3;
   */
  spec?: MetricsCapabilitySpec;

  constructor(data?: PartialMessage<MetricsCapabilityConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.MetricsCapabilityConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "conditions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "spec", kind: "message", T: MetricsCapabilitySpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsCapabilityConfig {
    return new MetricsCapabilityConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsCapabilityConfig | PlainMessage<MetricsCapabilityConfig> | undefined, b: MetricsCapabilityConfig | PlainMessage<MetricsCapabilityConfig> | undefined): boolean {
    return proto3.util.equals(MetricsCapabilityConfig, a, b);
  }
}

/**
 * @generated from message node.metrics.MetricsCapabilitySpec
 */
export class MetricsCapabilitySpec extends Message<MetricsCapabilitySpec> {
  /**
   * @generated from field: config.v1beta1.RulesSpec rules = 1;
   */
  rules?: RulesSpec;

  /**
   * @generated from oneof node.metrics.MetricsCapabilitySpec.driver
   */
  driver: {
    /**
     * @generated from field: node.metrics.PrometheusSpec prometheus = 2;
     */
    value: PrometheusSpec;
    case: "prometheus";
  } | {
    /**
     * @generated from field: node.metrics.OTELSpec otel = 3;
     */
    value: OTELSpec;
    case: "otel";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MetricsCapabilitySpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.MetricsCapabilitySpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rules", kind: "message", T: RulesSpec },
    { no: 2, name: "prometheus", kind: "message", T: PrometheusSpec, oneof: "driver" },
    { no: 3, name: "otel", kind: "message", T: OTELSpec, oneof: "driver" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsCapabilitySpec {
    return new MetricsCapabilitySpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsCapabilitySpec {
    return new MetricsCapabilitySpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsCapabilitySpec {
    return new MetricsCapabilitySpec().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsCapabilitySpec | PlainMessage<MetricsCapabilitySpec> | undefined, b: MetricsCapabilitySpec | PlainMessage<MetricsCapabilitySpec> | undefined): boolean {
    return proto3.util.equals(MetricsCapabilitySpec, a, b);
  }
}

/**
 * @generated from message node.metrics.PrometheusSpec
 */
export class PrometheusSpec extends Message<PrometheusSpec> {
  /**
   * default: quay.io/prometheus/prometheus:latest
   *
   * @generated from field: string image = 1;
   */
  image = "";

  /**
   * can be one of: ["externalPromOperator"]
   *
   * @generated from field: string deploymentStrategy = 2;
   */
  deploymentStrategy = "";

  constructor(data?: PartialMessage<PrometheusSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.PrometheusSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deploymentStrategy", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrometheusSpec {
    return new PrometheusSpec().fromJsonString(jsonString, options);
  }

  static equals(a: PrometheusSpec | PlainMessage<PrometheusSpec> | undefined, b: PrometheusSpec | PlainMessage<PrometheusSpec> | undefined): boolean {
    return proto3.util.equals(PrometheusSpec, a, b);
  }
}

/**
 * @generated from message node.metrics.OTELSpec
 */
export class OTELSpec extends Message<OTELSpec> {
  /**
   * @generated from field: repeated node.metrics.ScrapeConfig additionalScrapeConfigs = 1;
   */
  additionalScrapeConfigs: ScrapeConfig[] = [];

  /**
   * @generated from field: node.metrics.WALConfig wal = 2;
   */
  wal?: WALConfig;

  /**
   * @generated from field: optional bool hostMetrics = 3;
   */
  hostMetrics?: boolean;

  constructor(data?: PartialMessage<OTELSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.OTELSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "additionalScrapeConfigs", kind: "message", T: ScrapeConfig, repeated: true },
    { no: 2, name: "wal", kind: "message", T: WALConfig },
    { no: 3, name: "hostMetrics", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OTELSpec {
    return new OTELSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OTELSpec {
    return new OTELSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OTELSpec {
    return new OTELSpec().fromJsonString(jsonString, options);
  }

  static equals(a: OTELSpec | PlainMessage<OTELSpec> | undefined, b: OTELSpec | PlainMessage<OTELSpec> | undefined): boolean {
    return proto3.util.equals(OTELSpec, a, b);
  }
}

/**
 * @generated from message node.metrics.WALConfig
 */
export class WALConfig extends Message<WALConfig> {
  /**
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * @generated from field: int64 bufferSize = 2;
   */
  bufferSize = protoInt64.zero;

  /**
   * @generated from field: google.protobuf.Duration truncateFrequency = 3;
   */
  truncateFrequency?: Duration;

  constructor(data?: PartialMessage<WALConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.WALConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "bufferSize", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "truncateFrequency", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WALConfig {
    return new WALConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WALConfig {
    return new WALConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WALConfig {
    return new WALConfig().fromJsonString(jsonString, options);
  }

  static equals(a: WALConfig | PlainMessage<WALConfig> | undefined, b: WALConfig | PlainMessage<WALConfig> | undefined): boolean {
    return proto3.util.equals(WALConfig, a, b);
  }
}

/**
 * @generated from message node.metrics.SyncRequest
 */
export class SyncRequest extends Message<SyncRequest> {
  /**
   * @generated from field: node.metrics.MetricsCapabilityConfig currentConfig = 1;
   */
  currentConfig?: MetricsCapabilityConfig;

  constructor(data?: PartialMessage<SyncRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.SyncRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "currentConfig", kind: "message", T: MetricsCapabilityConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncRequest {
    return new SyncRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncRequest {
    return new SyncRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncRequest {
    return new SyncRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncRequest | PlainMessage<SyncRequest> | undefined, b: SyncRequest | PlainMessage<SyncRequest> | undefined): boolean {
    return proto3.util.equals(SyncRequest, a, b);
  }
}

/**
 * @generated from message node.metrics.ScrapeConfig
 */
export class ScrapeConfig extends Message<ScrapeConfig> {
  /**
   * @generated from field: string jobName = 1;
   */
  jobName = "";

  /**
   * @generated from field: repeated string targets = 2;
   */
  targets: string[] = [];

  /**
   * @generated from field: string scrapeInterval = 3;
   */
  scrapeInterval = "";

  constructor(data?: PartialMessage<ScrapeConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.ScrapeConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jobName", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "targets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "scrapeInterval", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrapeConfig {
    return new ScrapeConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ScrapeConfig | PlainMessage<ScrapeConfig> | undefined, b: ScrapeConfig | PlainMessage<ScrapeConfig> | undefined): boolean {
    return proto3.util.equals(ScrapeConfig, a, b);
  }
}

/**
 * @generated from message node.metrics.SyncResponse
 */
export class SyncResponse extends Message<SyncResponse> {
  /**
   * @generated from field: node.metrics.ConfigStatus configStatus = 1;
   */
  configStatus = ConfigStatus.Unknown;

  /**
   * @generated from field: node.metrics.MetricsCapabilityConfig updatedConfig = 2;
   */
  updatedConfig?: MetricsCapabilityConfig;

  constructor(data?: PartialMessage<SyncResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "node.metrics.SyncResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "configStatus", kind: "enum", T: proto3.getEnumType(ConfigStatus) },
    { no: 2, name: "updatedConfig", kind: "message", T: MetricsCapabilityConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncResponse {
    return new SyncResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncResponse {
    return new SyncResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncResponse {
    return new SyncResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncResponse | PlainMessage<SyncResponse> | undefined, b: SyncResponse | PlainMessage<SyncResponse> | undefined): boolean {
    return proto3.util.equals(SyncResponse, a, b);
  }
}

