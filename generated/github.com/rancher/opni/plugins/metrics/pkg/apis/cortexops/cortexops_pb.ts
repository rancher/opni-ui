// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/rancher/opni/plugins/metrics/pkg/apis/cortexops/cortexops.proto (package cortexops, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { StorageSpec } from "../../../../../pkg/apis/storage/v1/storage_pb";
import { Limits } from "../../../../../internal/cortex/config/validation/limits_pb";
import { Config } from "../../../../../internal/cortex/config/compactor/compactor_pb";
import { Config as Config$1 } from "../../../../../internal/cortex/config/querier/querier_pb";

/**
 * @generated from enum cortexops.InstallState
 */
export enum InstallState {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: NotInstalled = 1;
   */
  NotInstalled = 1,

  /**
   * @generated from enum value: Updating = 2;
   */
  Updating = 2,

  /**
   * @generated from enum value: Installed = 3;
   */
  Installed = 3,

  /**
   * @generated from enum value: Uninstalling = 4;
   */
  Uninstalling = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(InstallState)
proto3.util.setEnumType(InstallState, "cortexops.InstallState", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "NotInstalled" },
  { no: 2, name: "Updating" },
  { no: 3, name: "Installed" },
  { no: 4, name: "Uninstalling" },
]);

/**
 * @generated from enum cortexops.DeploymentMode
 */
export enum DeploymentMode {
  /**
   * All components are together in a single process. Not recommended for production use.
   *
   * @generated from enum value: AllInOne = 0;
   */
  AllInOne = 0,

  /**
   * Components are distributed across multiple processes.
   *
   * @generated from enum value: HighlyAvailable = 1;
   */
  HighlyAvailable = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DeploymentMode)
proto3.util.setEnumType(DeploymentMode, "cortexops.DeploymentMode", [
  { no: 0, name: "AllInOne" },
  { no: 1, name: "HighlyAvailable" },
]);

/**
 * @generated from message cortexops.InstallStatus
 */
export class InstallStatus extends Message<InstallStatus> {
  /**
   * @generated from field: cortexops.InstallState state = 1;
   */
  state = InstallState.Unknown;

  /**
   * @generated from field: string version = 2;
   */
  version = "";

  /**
   * @generated from field: map<string, string> metadata = 3;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<InstallStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.InstallStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(InstallState) },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstallStatus {
    return new InstallStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstallStatus {
    return new InstallStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstallStatus {
    return new InstallStatus().fromJsonString(jsonString, options);
  }

  static equals(a: InstallStatus | PlainMessage<InstallStatus> | undefined, b: InstallStatus | PlainMessage<InstallStatus> | undefined): boolean {
    return proto3.util.equals(InstallStatus, a, b);
  }
}

/**
 * @generated from message cortexops.ClusterConfiguration
 */
export class ClusterConfiguration extends Message<ClusterConfiguration> {
  /**
   * The deployment mode to use for Cortex.
   *
   * @generated from field: cortexops.DeploymentMode mode = 1;
   */
  mode = DeploymentMode.AllInOne;

  /**
   * @generated from field: storage.StorageSpec storage = 2;
   */
  storage?: StorageSpec;

  /**
   * @generated from field: cortexops.GrafanaConfig grafana = 3;
   */
  grafana?: GrafanaConfig;

  /**
   * @generated from field: cortexops.Workloads workloads = 4;
   */
  workloads?: Workloads;

  /**
   * @generated from field: cortexops.CortexConfig cortex = 5;
   */
  cortex?: CortexConfig;

  constructor(data?: PartialMessage<ClusterConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.ClusterConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mode", kind: "enum", T: proto3.getEnumType(DeploymentMode) },
    { no: 2, name: "storage", kind: "message", T: StorageSpec },
    { no: 3, name: "grafana", kind: "message", T: GrafanaConfig },
    { no: 4, name: "workloads", kind: "message", T: Workloads },
    { no: 5, name: "cortex", kind: "message", T: CortexConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterConfiguration {
    return new ClusterConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterConfiguration {
    return new ClusterConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterConfiguration {
    return new ClusterConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterConfiguration | PlainMessage<ClusterConfiguration> | undefined, b: ClusterConfiguration | PlainMessage<ClusterConfiguration> | undefined): boolean {
    return proto3.util.equals(ClusterConfiguration, a, b);
  }
}

/**
 * @generated from message cortexops.Workloads
 */
export class Workloads extends Message<Workloads> {
  /**
   * @generated from field: cortexops.CortexWorkloadSpec distributor = 1;
   */
  distributor?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec ingester = 2;
   */
  ingester?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec compactor = 3;
   */
  compactor?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec storeGateway = 4;
   */
  storeGateway?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec ruler = 5;
   */
  ruler?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec queryFrontend = 6;
   */
  queryFrontend?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec querier = 7;
   */
  querier?: CortexWorkloadSpec;

  /**
   * @generated from field: cortexops.CortexWorkloadSpec purger = 8;
   */
  purger?: CortexWorkloadSpec;

  constructor(data?: PartialMessage<Workloads>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.Workloads";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "distributor", kind: "message", T: CortexWorkloadSpec },
    { no: 2, name: "ingester", kind: "message", T: CortexWorkloadSpec },
    { no: 3, name: "compactor", kind: "message", T: CortexWorkloadSpec },
    { no: 4, name: "storeGateway", kind: "message", T: CortexWorkloadSpec },
    { no: 5, name: "ruler", kind: "message", T: CortexWorkloadSpec },
    { no: 6, name: "queryFrontend", kind: "message", T: CortexWorkloadSpec },
    { no: 7, name: "querier", kind: "message", T: CortexWorkloadSpec },
    { no: 8, name: "purger", kind: "message", T: CortexWorkloadSpec },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Workloads {
    return new Workloads().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Workloads {
    return new Workloads().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Workloads {
    return new Workloads().fromJsonString(jsonString, options);
  }

  static equals(a: Workloads | PlainMessage<Workloads> | undefined, b: Workloads | PlainMessage<Workloads> | undefined): boolean {
    return proto3.util.equals(Workloads, a, b);
  }
}

/**
 * @generated from message cortexops.CortexWorkloadSpec
 */
export class CortexWorkloadSpec extends Message<CortexWorkloadSpec> {
  /**
   * Number of replicas to run for this workload. Should be an odd number.
   *
   * @generated from field: int32 replicas = 1;
   */
  replicas = 0;

  /**
   * Any additional arguments to pass to Cortex.
   *
   * @generated from field: repeated string extraArgs = 2;
   */
  extraArgs: string[] = [];

  constructor(data?: PartialMessage<CortexWorkloadSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.CortexWorkloadSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "replicas", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "extraArgs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CortexWorkloadSpec {
    return new CortexWorkloadSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CortexWorkloadSpec {
    return new CortexWorkloadSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CortexWorkloadSpec {
    return new CortexWorkloadSpec().fromJsonString(jsonString, options);
  }

  static equals(a: CortexWorkloadSpec | PlainMessage<CortexWorkloadSpec> | undefined, b: CortexWorkloadSpec | PlainMessage<CortexWorkloadSpec> | undefined): boolean {
    return proto3.util.equals(CortexWorkloadSpec, a, b);
  }
}

/**
 * @generated from message cortexops.CortexConfig
 */
export class CortexConfig extends Message<CortexConfig> {
  /**
   * @generated from field: validation.Limits limits = 1;
   */
  limits?: Limits;

  /**
   * @generated from field: map<string, validation.Limits> tenantLimits = 2;
   */
  tenantLimits: { [key: string]: Limits } = {};

  /**
   * @generated from field: compactor.Config compactor = 3;
   */
  compactor?: Config;

  /**
   * @generated from field: querier.Config querier = 4;
   */
  querier?: Config$1;

  constructor(data?: PartialMessage<CortexConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.CortexConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limits", kind: "message", T: Limits },
    { no: 2, name: "tenantLimits", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Limits} },
    { no: 3, name: "compactor", kind: "message", T: Config },
    { no: 4, name: "querier", kind: "message", T: Config$1 },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CortexConfig {
    return new CortexConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CortexConfig {
    return new CortexConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CortexConfig {
    return new CortexConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CortexConfig | PlainMessage<CortexConfig> | undefined, b: CortexConfig | PlainMessage<CortexConfig> | undefined): boolean {
    return proto3.util.equals(CortexConfig, a, b);
  }
}

/**
 * @generated from message cortexops.GrafanaConfig
 */
export class GrafanaConfig extends Message<GrafanaConfig> {
  /**
   * Whether to deploy a managed Grafana instance.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * DNS name at which Grafana will be available in the browser.
   *
   * @generated from field: string hostname = 2;
   */
  hostname = "";

  constructor(data?: PartialMessage<GrafanaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexops.GrafanaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrafanaConfig {
    return new GrafanaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrafanaConfig {
    return new GrafanaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrafanaConfig {
    return new GrafanaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GrafanaConfig | PlainMessage<GrafanaConfig> | undefined, b: GrafanaConfig | PlainMessage<GrafanaConfig> | undefined): boolean {
    return proto3.util.equals(GrafanaConfig, a, b);
  }
}

