// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/cortexproject/cortex/pkg/cortexpb/cortex.proto (package cortexpb, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from message cortexpb.WriteRequest
 */
export class WriteRequest extends Message<WriteRequest> {
  /**
   * @generated from field: repeated cortexpb.TimeSeries timeseries = 1;
   */
  timeseries: TimeSeries[] = [];

  /**
   * @generated from field: cortexpb.WriteRequest.SourceEnum Source = 2;
   */
  Source = WriteRequest_SourceEnum.API;

  /**
   * @generated from field: repeated cortexpb.MetricMetadata metadata = 3;
   */
  metadata: MetricMetadata[] = [];

  /**
   * set intentionally high to keep WriteRequest compatible with upstream Prometheus
   *
   * @generated from field: bool skip_label_name_validation = 1000;
   */
  skipLabelNameValidation = false;

  constructor(data?: PartialMessage<WriteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.WriteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timeseries", kind: "message", T: TimeSeries, repeated: true },
    { no: 2, name: "Source", kind: "enum", T: proto3.getEnumType(WriteRequest_SourceEnum) },
    { no: 3, name: "metadata", kind: "message", T: MetricMetadata, repeated: true },
    { no: 1000, name: "skip_label_name_validation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteRequest {
    return new WriteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteRequest {
    return new WriteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteRequest {
    return new WriteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WriteRequest | PlainMessage<WriteRequest> | undefined, b: WriteRequest | PlainMessage<WriteRequest> | undefined): boolean {
    return proto3.util.equals(WriteRequest, a, b);
  }
}

/**
 * @generated from enum cortexpb.WriteRequest.SourceEnum
 */
export enum WriteRequest_SourceEnum {
  /**
   * @generated from enum value: API = 0;
   */
  API = 0,

  /**
   * @generated from enum value: RULE = 1;
   */
  RULE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(WriteRequest_SourceEnum)
proto3.util.setEnumType(WriteRequest_SourceEnum, "cortexpb.WriteRequest.SourceEnum", [
  { no: 0, name: "API" },
  { no: 1, name: "RULE" },
]);

/**
 * @generated from message cortexpb.WriteResponse
 */
export class WriteResponse extends Message<WriteResponse> {
  constructor(data?: PartialMessage<WriteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.WriteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteResponse {
    return new WriteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteResponse {
    return new WriteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteResponse {
    return new WriteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WriteResponse | PlainMessage<WriteResponse> | undefined, b: WriteResponse | PlainMessage<WriteResponse> | undefined): boolean {
    return proto3.util.equals(WriteResponse, a, b);
  }
}

/**
 * @generated from message cortexpb.TimeSeries
 */
export class TimeSeries extends Message<TimeSeries> {
  /**
   * @generated from field: repeated cortexpb.LabelPair labels = 1;
   */
  labels: LabelPair[] = [];

  /**
   * Sorted by time, oldest sample first.
   *
   * @generated from field: repeated cortexpb.Sample samples = 2;
   */
  samples: Sample[] = [];

  /**
   * @generated from field: repeated cortexpb.Exemplar exemplars = 3;
   */
  exemplars: Exemplar[] = [];

  constructor(data?: PartialMessage<TimeSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.TimeSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: LabelPair, repeated: true },
    { no: 2, name: "samples", kind: "message", T: Sample, repeated: true },
    { no: 3, name: "exemplars", kind: "message", T: Exemplar, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeSeries {
    return new TimeSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeSeries {
    return new TimeSeries().fromJsonString(jsonString, options);
  }

  static equals(a: TimeSeries | PlainMessage<TimeSeries> | undefined, b: TimeSeries | PlainMessage<TimeSeries> | undefined): boolean {
    return proto3.util.equals(TimeSeries, a, b);
  }
}

/**
 * @generated from message cortexpb.LabelPair
 */
export class LabelPair extends Message<LabelPair> {
  /**
   * @generated from field: bytes name = 1;
   */
  name = new Uint8Array(0);

  /**
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<LabelPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.LabelPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelPair {
    return new LabelPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelPair {
    return new LabelPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelPair {
    return new LabelPair().fromJsonString(jsonString, options);
  }

  static equals(a: LabelPair | PlainMessage<LabelPair> | undefined, b: LabelPair | PlainMessage<LabelPair> | undefined): boolean {
    return proto3.util.equals(LabelPair, a, b);
  }
}

/**
 * @generated from message cortexpb.Sample
 */
export class Sample extends Message<Sample> {
  /**
   * @generated from field: double value = 1;
   */
  value = 0;

  /**
   * @generated from field: int64 timestamp_ms = 2;
   */
  timestampMs = protoInt64.zero;

  constructor(data?: PartialMessage<Sample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.Sample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sample {
    return new Sample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJsonString(jsonString, options);
  }

  static equals(a: Sample | PlainMessage<Sample> | undefined, b: Sample | PlainMessage<Sample> | undefined): boolean {
    return proto3.util.equals(Sample, a, b);
  }
}

/**
 * @generated from message cortexpb.MetricMetadata
 */
export class MetricMetadata extends Message<MetricMetadata> {
  /**
   * @generated from field: cortexpb.MetricMetadata.MetricType type = 1;
   */
  type = MetricMetadata_MetricType.UNKNOWN;

  /**
   * @generated from field: string metric_family_name = 2;
   */
  metricFamilyName = "";

  /**
   * @generated from field: string help = 4;
   */
  help = "";

  /**
   * @generated from field: string unit = 5;
   */
  unit = "";

  constructor(data?: PartialMessage<MetricMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.MetricMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(MetricMetadata_MetricType) },
    { no: 2, name: "metric_family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "help", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricMetadata {
    return new MetricMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricMetadata {
    return new MetricMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricMetadata {
    return new MetricMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MetricMetadata | PlainMessage<MetricMetadata> | undefined, b: MetricMetadata | PlainMessage<MetricMetadata> | undefined): boolean {
    return proto3.util.equals(MetricMetadata, a, b);
  }
}

/**
 * @generated from enum cortexpb.MetricMetadata.MetricType
 */
export enum MetricMetadata_MetricType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: COUNTER = 1;
   */
  COUNTER = 1,

  /**
   * @generated from enum value: GAUGE = 2;
   */
  GAUGE = 2,

  /**
   * @generated from enum value: HISTOGRAM = 3;
   */
  HISTOGRAM = 3,

  /**
   * @generated from enum value: GAUGEHISTOGRAM = 4;
   */
  GAUGEHISTOGRAM = 4,

  /**
   * @generated from enum value: SUMMARY = 5;
   */
  SUMMARY = 5,

  /**
   * @generated from enum value: INFO = 6;
   */
  INFO = 6,

  /**
   * @generated from enum value: STATESET = 7;
   */
  STATESET = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(MetricMetadata_MetricType)
proto3.util.setEnumType(MetricMetadata_MetricType, "cortexpb.MetricMetadata.MetricType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "COUNTER" },
  { no: 2, name: "GAUGE" },
  { no: 3, name: "HISTOGRAM" },
  { no: 4, name: "GAUGEHISTOGRAM" },
  { no: 5, name: "SUMMARY" },
  { no: 6, name: "INFO" },
  { no: 7, name: "STATESET" },
]);

/**
 * @generated from message cortexpb.Metric
 */
export class Metric extends Message<Metric> {
  /**
   * @generated from field: repeated cortexpb.LabelPair labels = 1;
   */
  labels: LabelPair[] = [];

  constructor(data?: PartialMessage<Metric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.Metric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: LabelPair, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metric {
    return new Metric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJsonString(jsonString, options);
  }

  static equals(a: Metric | PlainMessage<Metric> | undefined, b: Metric | PlainMessage<Metric> | undefined): boolean {
    return proto3.util.equals(Metric, a, b);
  }
}

/**
 * @generated from message cortexpb.Exemplar
 */
export class Exemplar extends Message<Exemplar> {
  /**
   * Exemplar labels, different than series labels
   *
   * @generated from field: repeated cortexpb.LabelPair labels = 1;
   */
  labels: LabelPair[] = [];

  /**
   * @generated from field: double value = 2;
   */
  value = 0;

  /**
   * @generated from field: int64 timestamp_ms = 3;
   */
  timestampMs = protoInt64.zero;

  constructor(data?: PartialMessage<Exemplar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cortexpb.Exemplar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "message", T: LabelPair, repeated: true },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exemplar {
    return new Exemplar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJsonString(jsonString, options);
  }

  static equals(a: Exemplar | PlainMessage<Exemplar> | undefined, b: Exemplar | PlainMessage<Exemplar> | undefined): boolean {
    return proto3.util.equals(Exemplar, a, b);
  }
}

