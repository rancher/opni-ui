// Copyright 2013 Prometheus Team
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.2.1 with parameter "target=ts,import_extension=none"
// @generated from file github.com/prometheus/client_model/io/prometheus/client/metrics.proto (package io.prometheus.client, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";
import { Timestamp } from "../../../../../../google/protobuf/timestamp_pb";

/**
 * @generated from enum io.prometheus.client.MetricType
 */
export enum MetricType {
  /**
   * COUNTER must use the Metric field "counter".
   *
   * @generated from enum value: COUNTER = 0;
   */
  COUNTER = 0,

  /**
   * GAUGE must use the Metric field "gauge".
   *
   * @generated from enum value: GAUGE = 1;
   */
  GAUGE = 1,

  /**
   * SUMMARY must use the Metric field "summary".
   *
   * @generated from enum value: SUMMARY = 2;
   */
  SUMMARY = 2,

  /**
   * UNTYPED must use the Metric field "untyped".
   *
   * @generated from enum value: UNTYPED = 3;
   */
  UNTYPED = 3,

  /**
   * HISTOGRAM must use the Metric field "histogram".
   *
   * @generated from enum value: HISTOGRAM = 4;
   */
  HISTOGRAM = 4,

  /**
   * GAUGE_HISTOGRAM must use the Metric field "histogram".
   *
   * @generated from enum value: GAUGE_HISTOGRAM = 5;
   */
  GAUGE_HISTOGRAM = 5,
}
// Retrieve enum metadata with: proto2.getEnumType(MetricType)
proto2.util.setEnumType(MetricType, "io.prometheus.client.MetricType", [
  { no: 0, name: "COUNTER" },
  { no: 1, name: "GAUGE" },
  { no: 2, name: "SUMMARY" },
  { no: 3, name: "UNTYPED" },
  { no: 4, name: "HISTOGRAM" },
  { no: 5, name: "GAUGE_HISTOGRAM" },
]);

/**
 * @generated from message io.prometheus.client.LabelPair
 */
export class LabelPair extends Message<LabelPair> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string value = 2;
   */
  value?: string;

  constructor(data?: PartialMessage<LabelPair>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.LabelPair";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelPair {
    return new LabelPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelPair {
    return new LabelPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelPair {
    return new LabelPair().fromJsonString(jsonString, options);
  }

  static equals(a: LabelPair | PlainMessage<LabelPair> | undefined, b: LabelPair | PlainMessage<LabelPair> | undefined): boolean {
    return proto2.util.equals(LabelPair, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Gauge
 */
export class Gauge extends Message<Gauge> {
  /**
   * @generated from field: optional double value = 1;
   */
  value?: number;

  constructor(data?: PartialMessage<Gauge>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Gauge";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Gauge {
    return new Gauge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Gauge {
    return new Gauge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Gauge {
    return new Gauge().fromJsonString(jsonString, options);
  }

  static equals(a: Gauge | PlainMessage<Gauge> | undefined, b: Gauge | PlainMessage<Gauge> | undefined): boolean {
    return proto2.util.equals(Gauge, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Counter
 */
export class Counter extends Message<Counter> {
  /**
   * @generated from field: optional double value = 1;
   */
  value?: number;

  /**
   * @generated from field: optional io.prometheus.client.Exemplar exemplar = 2;
   */
  exemplar?: Exemplar;

  constructor(data?: PartialMessage<Counter>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Counter";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "exemplar", kind: "message", T: Exemplar, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Counter {
    return new Counter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Counter {
    return new Counter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Counter {
    return new Counter().fromJsonString(jsonString, options);
  }

  static equals(a: Counter | PlainMessage<Counter> | undefined, b: Counter | PlainMessage<Counter> | undefined): boolean {
    return proto2.util.equals(Counter, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Quantile
 */
export class Quantile extends Message<Quantile> {
  /**
   * @generated from field: optional double quantile = 1;
   */
  quantile?: number;

  /**
   * @generated from field: optional double value = 2;
   */
  value?: number;

  constructor(data?: PartialMessage<Quantile>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Quantile";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "quantile", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quantile {
    return new Quantile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quantile {
    return new Quantile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quantile {
    return new Quantile().fromJsonString(jsonString, options);
  }

  static equals(a: Quantile | PlainMessage<Quantile> | undefined, b: Quantile | PlainMessage<Quantile> | undefined): boolean {
    return proto2.util.equals(Quantile, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Summary
 */
export class Summary extends Message<Summary> {
  /**
   * @generated from field: optional uint64 sample_count = 1;
   */
  sampleCount?: bigint;

  /**
   * @generated from field: optional double sample_sum = 2;
   */
  sampleSum?: number;

  /**
   * @generated from field: repeated io.prometheus.client.Quantile quantile = 3;
   */
  quantile: Quantile[] = [];

  constructor(data?: PartialMessage<Summary>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Summary";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sample_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "sample_sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "quantile", kind: "message", T: Quantile, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Summary {
    return new Summary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Summary {
    return new Summary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Summary {
    return new Summary().fromJsonString(jsonString, options);
  }

  static equals(a: Summary | PlainMessage<Summary> | undefined, b: Summary | PlainMessage<Summary> | undefined): boolean {
    return proto2.util.equals(Summary, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Untyped
 */
export class Untyped extends Message<Untyped> {
  /**
   * @generated from field: optional double value = 1;
   */
  value?: number;

  constructor(data?: PartialMessage<Untyped>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Untyped";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Untyped {
    return new Untyped().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Untyped {
    return new Untyped().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Untyped {
    return new Untyped().fromJsonString(jsonString, options);
  }

  static equals(a: Untyped | PlainMessage<Untyped> | undefined, b: Untyped | PlainMessage<Untyped> | undefined): boolean {
    return proto2.util.equals(Untyped, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Histogram
 */
export class Histogram extends Message<Histogram> {
  /**
   * @generated from field: optional uint64 sample_count = 1;
   */
  sampleCount?: bigint;

  /**
   * Overrides sample_count if > 0.
   *
   * @generated from field: optional double sample_count_float = 4;
   */
  sampleCountFloat?: number;

  /**
   * @generated from field: optional double sample_sum = 2;
   */
  sampleSum?: number;

  /**
   * Buckets for the conventional histogram.
   *
   * Ordered in increasing order of upper_bound, +Inf bucket is optional.
   *
   * @generated from field: repeated io.prometheus.client.Bucket bucket = 3;
   */
  bucket: Bucket[] = [];

  /**
   * schema defines the bucket schema. Currently, valid numbers are -4 <= n <= 8.
   * They are all for base-2 bucket schemas, where 1 is a bucket boundary in each case, and
   * then each power of two is divided into 2^n logarithmic buckets.
   * Or in other words, each bucket boundary is the previous boundary times 2^(2^-n).
   * In the future, more bucket schemas may be added using numbers < -4 or > 8.
   *
   * @generated from field: optional sint32 schema = 5;
   */
  schema?: number;

  /**
   * Breadth of the zero bucket.
   *
   * @generated from field: optional double zero_threshold = 6;
   */
  zeroThreshold?: number;

  /**
   * Count in zero bucket.
   *
   * @generated from field: optional uint64 zero_count = 7;
   */
  zeroCount?: bigint;

  /**
   * Overrides sb_zero_count if > 0.
   *
   * @generated from field: optional double zero_count_float = 8;
   */
  zeroCountFloat?: number;

  /**
   * Negative buckets for the native histogram.
   *
   * @generated from field: repeated io.prometheus.client.BucketSpan negative_span = 9;
   */
  negativeSpan: BucketSpan[] = [];

  /**
   * Use either "negative_delta" or "negative_count", the former for
   * regular histograms with integer counts, the latter for float
   * histograms.
   *
   * Count delta of each bucket compared to previous one (or to zero for 1st bucket).
   *
   * @generated from field: repeated sint64 negative_delta = 10;
   */
  negativeDelta: bigint[] = [];

  /**
   * Absolute count of each bucket.
   *
   * @generated from field: repeated double negative_count = 11;
   */
  negativeCount: number[] = [];

  /**
   * Positive buckets for the native histogram.
   *
   * @generated from field: repeated io.prometheus.client.BucketSpan positive_span = 12;
   */
  positiveSpan: BucketSpan[] = [];

  /**
   * Use either "positive_delta" or "positive_count", the former for
   * regular histograms with integer counts, the latter for float
   * histograms.
   *
   * Count delta of each bucket compared to previous one (or to zero for 1st bucket).
   *
   * @generated from field: repeated sint64 positive_delta = 13;
   */
  positiveDelta: bigint[] = [];

  /**
   * Absolute count of each bucket.
   *
   * @generated from field: repeated double positive_count = 14;
   */
  positiveCount: number[] = [];

  constructor(data?: PartialMessage<Histogram>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Histogram";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "sample_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "sample_count_float", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "sample_sum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "bucket", kind: "message", T: Bucket, repeated: true },
    { no: 5, name: "schema", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 6, name: "zero_threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "zero_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 8, name: "zero_count_float", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 9, name: "negative_span", kind: "message", T: BucketSpan, repeated: true },
    { no: 10, name: "negative_delta", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 11, name: "negative_count", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
    { no: 12, name: "positive_span", kind: "message", T: BucketSpan, repeated: true },
    { no: 13, name: "positive_delta", kind: "scalar", T: 18 /* ScalarType.SINT64 */, repeated: true },
    { no: 14, name: "positive_count", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Histogram {
    return new Histogram().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Histogram {
    return new Histogram().fromJsonString(jsonString, options);
  }

  static equals(a: Histogram | PlainMessage<Histogram> | undefined, b: Histogram | PlainMessage<Histogram> | undefined): boolean {
    return proto2.util.equals(Histogram, a, b);
  }
}

/**
 * A Bucket of a conventional histogram, each of which is treated as
 * an individual counter-like time series by Prometheus.
 *
 * @generated from message io.prometheus.client.Bucket
 */
export class Bucket extends Message<Bucket> {
  /**
   * Cumulative in increasing order.
   *
   * @generated from field: optional uint64 cumulative_count = 1;
   */
  cumulativeCount?: bigint;

  /**
   * Overrides cumulative_count if > 0.
   *
   * @generated from field: optional double cumulative_count_float = 4;
   */
  cumulativeCountFloat?: number;

  /**
   * Inclusive.
   *
   * @generated from field: optional double upper_bound = 2;
   */
  upperBound?: number;

  /**
   * @generated from field: optional io.prometheus.client.Exemplar exemplar = 3;
   */
  exemplar?: Exemplar;

  constructor(data?: PartialMessage<Bucket>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Bucket";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "cumulative_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "cumulative_count_float", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "upper_bound", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "exemplar", kind: "message", T: Exemplar, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bucket {
    return new Bucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bucket {
    return new Bucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bucket {
    return new Bucket().fromJsonString(jsonString, options);
  }

  static equals(a: Bucket | PlainMessage<Bucket> | undefined, b: Bucket | PlainMessage<Bucket> | undefined): boolean {
    return proto2.util.equals(Bucket, a, b);
  }
}

/**
 * A BucketSpan defines a number of consecutive buckets in a native
 * histogram with their offset. Logically, it would be more
 * straightforward to include the bucket counts in the Span. However,
 * the protobuf representation is more compact in the way the data is
 * structured here (with all the buckets in a single array separate
 * from the Spans).
 *
 * @generated from message io.prometheus.client.BucketSpan
 */
export class BucketSpan extends Message<BucketSpan> {
  /**
   * Gap to previous span, or starting point for 1st span (which can be negative).
   *
   * @generated from field: optional sint32 offset = 1;
   */
  offset?: number;

  /**
   * Length of consecutive buckets.
   *
   * @generated from field: optional uint32 length = 2;
   */
  length?: number;

  constructor(data?: PartialMessage<BucketSpan>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.BucketSpan";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "offset", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 2, name: "length", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketSpan {
    return new BucketSpan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketSpan {
    return new BucketSpan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketSpan {
    return new BucketSpan().fromJsonString(jsonString, options);
  }

  static equals(a: BucketSpan | PlainMessage<BucketSpan> | undefined, b: BucketSpan | PlainMessage<BucketSpan> | undefined): boolean {
    return proto2.util.equals(BucketSpan, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Exemplar
 */
export class Exemplar extends Message<Exemplar> {
  /**
   * @generated from field: repeated io.prometheus.client.LabelPair label = 1;
   */
  label: LabelPair[] = [];

  /**
   * @generated from field: optional double value = 2;
   */
  value?: number;

  /**
   * OpenMetrics-style.
   *
   * @generated from field: optional google.protobuf.Timestamp timestamp = 3;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Exemplar>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Exemplar";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "label", kind: "message", T: LabelPair, repeated: true },
    { no: 2, name: "value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "timestamp", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Exemplar {
    return new Exemplar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Exemplar {
    return new Exemplar().fromJsonString(jsonString, options);
  }

  static equals(a: Exemplar | PlainMessage<Exemplar> | undefined, b: Exemplar | PlainMessage<Exemplar> | undefined): boolean {
    return proto2.util.equals(Exemplar, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.Metric
 */
export class Metric extends Message<Metric> {
  /**
   * @generated from field: repeated io.prometheus.client.LabelPair label = 1;
   */
  label: LabelPair[] = [];

  /**
   * @generated from field: optional io.prometheus.client.Gauge gauge = 2;
   */
  gauge?: Gauge;

  /**
   * @generated from field: optional io.prometheus.client.Counter counter = 3;
   */
  counter?: Counter;

  /**
   * @generated from field: optional io.prometheus.client.Summary summary = 4;
   */
  summary?: Summary;

  /**
   * @generated from field: optional io.prometheus.client.Untyped untyped = 5;
   */
  untyped?: Untyped;

  /**
   * @generated from field: optional io.prometheus.client.Histogram histogram = 7;
   */
  histogram?: Histogram;

  /**
   * @generated from field: optional int64 timestamp_ms = 6;
   */
  timestampMs?: bigint;

  constructor(data?: PartialMessage<Metric>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.Metric";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "label", kind: "message", T: LabelPair, repeated: true },
    { no: 2, name: "gauge", kind: "message", T: Gauge, opt: true },
    { no: 3, name: "counter", kind: "message", T: Counter, opt: true },
    { no: 4, name: "summary", kind: "message", T: Summary, opt: true },
    { no: 5, name: "untyped", kind: "message", T: Untyped, opt: true },
    { no: 7, name: "histogram", kind: "message", T: Histogram, opt: true },
    { no: 6, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metric {
    return new Metric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metric {
    return new Metric().fromJsonString(jsonString, options);
  }

  static equals(a: Metric | PlainMessage<Metric> | undefined, b: Metric | PlainMessage<Metric> | undefined): boolean {
    return proto2.util.equals(Metric, a, b);
  }
}

/**
 * @generated from message io.prometheus.client.MetricFamily
 */
export class MetricFamily extends Message<MetricFamily> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string help = 2;
   */
  help?: string;

  /**
   * @generated from field: optional io.prometheus.client.MetricType type = 3;
   */
  type?: MetricType;

  /**
   * @generated from field: repeated io.prometheus.client.Metric metric = 4;
   */
  metric: Metric[] = [];

  constructor(data?: PartialMessage<MetricFamily>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "io.prometheus.client.MetricFamily";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "help", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "type", kind: "enum", T: proto2.getEnumType(MetricType), opt: true },
    { no: 4, name: "metric", kind: "message", T: Metric, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricFamily {
    return new MetricFamily().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricFamily {
    return new MetricFamily().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricFamily {
    return new MetricFamily().fromJsonString(jsonString, options);
  }

  static equals(a: MetricFamily | PlainMessage<MetricFamily> | undefined, b: MetricFamily | PlainMessage<MetricFamily> | undefined): boolean {
    return proto2.util.equals(MetricFamily, a, b);
  }
}

